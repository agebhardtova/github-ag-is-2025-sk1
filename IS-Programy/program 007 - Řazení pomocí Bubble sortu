using SysteDiagnostics.CodeAnalysis;
using System.Diagnostics;

string again = "a";
while (again == "a")
{
    Console.Clear();
    Console.WriteLine("************************************************");
    Console.WriteLine("******************* Bubble sort ****************");
    Console.WriteLine("************************************************");
    Console.WriteLine("************** Anna Gebhardtová *****************");
    Console.WriteLine("************************************************");
    Console.WriteLine();

    // Vstup hodnoty do programu - špatně řešený
    //Console.Write("Zadejte první číslo řady: ");
    //int first = int.Parse(Console.ReadLine());

    //Vstup hodnoty do programu - řešený správně
    Console.Write("Zadejte počet generovaných čísel (celé číslo): ");
    int n; //proměnná pro počet čísel n 

    while (!int.TryParse(Console.ReadLine(), out n))
    {
        Console.Write("Nezadali jste celé číslo. Zadejte znovu počet čísel: ");
    }

    //DOLNÍ MEZ 
    Console.Write("Zadejte dolní mez (celé číslo): ");
    int lowerBound;

    while (!int.TryParse(Console.ReadLine(), out lowerBound))
    {
        Console.Write("Nezadali jste celé číslo. Zadejte znovu dolní mez: ");
    }


    //HORNÍ MEZ 
    Console.Write("Zadejte horní mez (celé číslo): ");
    int upperBound;
            
             // || upperbound < lowerbound - dvě čárky jsou OR - je to číslo nebo není číslo n  a zároveň je horní mez větší než dolní mez
    while (!int.TryParse(Console.ReadLine(), out upperBound) || upperBound < lowerBound)
    // explaination: while the input is not an integer *OR* the upper bound is LESS THAN the lower bound
    {
        if (upperBound < lowerBound)
        {
            Console.Write($"horní mez musí být větší než dolní mez ({lowerBound}). Zadejte horní mez znovu: ");
        }
        else
        {
            Console.Write("Nezadali jste celé číslo. Zadejte znovu horní mez: ");
        }
    }



int compare = 0;
int change = 0; 



//BUBBLE SORT - generování náhodných čísel do pole 
 //základem algoritmu bude cyklus 

 for(int i = 0; i < n - 1 ; i++) //hlavní operace se provedlo tolikrát, kolik je prvků v poli
    { //patří do hlavního cyklu, a nesmíme použít hlavní řídící proměnnou i ZNOVU
       
       for(int j = 0; j < n ; j++) //vnořený cyklus - porovnáváme vždy dva sousední prvky
        {               //místo indexu i použijeme index j
            if(myRandomNumbers[j] > myRandomNumbers[j + 1]) //porovnání dvou sousedních prvků - hned následný - PROTO j + 1
            {   //určuje jak se bude řadit - vzestupně nebo sestupně


                //prohodit hodnoty - NOVÁ PROMĚNNÁ TEMP JAKO TEMPORARY - DOČASNÁ PROMĚNNÁ
                int temp = myRandomNumbers[j + 1]; //do dočasné proměnné uložíme hodnotu prvku j
                myRandomNumbers[j + 1] = myRandomNumbers[j]; //do prvku j uložíme hodnotu prvku j + 1
                myRandomNumbers[j] = temp; //do prvku j + 1 uložíme hodnotu z dočasné proměnné


 // POKUD SE STANE IF, TAK DOJDE K VÝMĚNĚ HODNOT
 change++; //počítadlo změn hodnot
                //to co máme na právě straně jde potom na levou stranu 
            } //if je true - dojde k výměně hodnot - were supposed to do something with else or idk

            else
            {
                compare++; //počítadlo porovnání 
            } 
       
        } 

    }  







... (zbývá 46 řádků)